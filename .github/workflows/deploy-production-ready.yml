name: üöÄ Production Deployment (Docker Ready)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  DEPLOY_DIR: /home/${{ secrets.VM_USER }}/helpdesk-deployment

jobs:
  deploy:
    name: üöÄ Deploy Helpdesk System
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: üîë Add VM to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts

      - name: ‚úÖ Verify Docker Access
        run: |
          echo "‚úÖ Verifying Docker access..."
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            echo 'Current user: \$(whoami)'
            echo 'Current groups: \$(groups)'
            echo 'Testing Docker access:'
            docker --version
            docker ps
            echo '‚úÖ Docker access confirmed!'
          "

      - name: üßπ Clean Previous Deployment
        run: |
          echo "üßπ Cleaning previous deployment..."
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            # Stop existing containers
            if [ -f $DEPLOY_DIR/docker-compose.prod.yml ]; then
              cd $DEPLOY_DIR
              docker-compose -f docker-compose.prod.yml down --remove-orphans || echo 'No containers to stop'
            fi
            
            # Clean up old deployment
            rm -rf $DEPLOY_DIR || echo 'No previous deployment to clean'
            
            # Clean Docker system
            docker system prune -f
            
            echo '‚úÖ Cleanup completed'
          "

      - name: üìÇ Create Deployment Directory
        run: |
          echo "üìÇ Creating deployment directory..."
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            mkdir -p $DEPLOY_DIR
            cd $DEPLOY_DIR
            echo 'Deployment directory: \$(pwd)'
          "

      - name: üì§ Upload Application Files
        run: |
          echo "üì§ Uploading application files..."

          # Verify files exist before creating archive
          ls -la .env.production || echo "Warning: .env.production not found"
          ls -la deploy-production.sh || echo "Warning: deploy-production.sh not found"
          ls -la docker-compose.prod.yml || echo "Warning: docker-compose.prod.yml not found"

          # Create deployment archive with existing files only
          tar -czf helpdesk-deploy.tar.gz \
            backend/ \
            frontend/ \
            docker-compose.prod.yml

          # Upload to VM
          scp helpdesk-deploy.tar.gz ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }}:$DEPLOY_DIR/

          # Extract on VM
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            cd $DEPLOY_DIR
            tar -xzf helpdesk-deploy.tar.gz
            rm helpdesk-deploy.tar.gz
            echo '‚úÖ Files uploaded and extracted'
            ls -la
          "

      - name: üîß Set Permissions
        run: |
          echo "üîß Setting file permissions and environment..."
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            cd $DEPLOY_DIR
            chmod +x *.sh 2>/dev/null || echo 'No shell scripts to make executable'
            
            # Create production environment file
            echo 'Creating .env.production file...'
            echo 'NODE_ENV=production' > .env.production
            echo 'PORT=3001' >> .env.production
            echo 'DB_HOST=helpdesk-postgres-prod' >> .env.production
            echo 'DB_PORT=5432' >> .env.production
            echo 'DB_NAME=helpdesk_db' >> .env.production
            echo 'DB_USER=helpdesk_user' >> .env.production
            echo 'DB_PASSWORD=HelpDesk2025SecurePassword!' >> .env.production
            echo 'JWT_SECRET=your-super-secure-jwt-secret-must-be-at-least-256-bits-long-for-production-security' >> .env.production
            echo 'API_URL=http://34.173.186.108:3001/api' >> .env.production
            echo 'FRONTEND_URL=http://34.173.186.108' >> .env.production
            echo 'CORS_ORIGIN=http://34.173.186.108' >> .env.production
            echo 'BCRYPT_ROUNDS=12' >> .env.production
            echo 'RATE_LIMIT_WINDOW_MS=900000' >> .env.production
            echo 'RATE_LIMIT_MAX_REQUESTS=100' >> .env.production
            
            echo '‚úÖ Environment file created'
            echo '‚úÖ Permissions set'
          "

      - name: üê≥ Build Docker Images
        run: |
          echo "üê≥ Building Docker images..."
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            cd $DEPLOY_DIR
            
            echo 'Building backend image...'
            docker build -t helpdesk-backend:latest ./backend/
            
            echo 'Building frontend image...'
            docker build -t helpdesk-frontend:latest ./frontend/
            
            echo '‚úÖ Docker images built successfully'
            docker images | grep helpdesk
          "

      - name: üöÄ Deploy Application
        run: |
          echo "üöÄ Starting application containers..."
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            cd $DEPLOY_DIR
            
            # Load environment variables
            export \$(cat .env.production | xargs)
            
            echo 'Environment variables loaded:'
            echo 'DB_PASSWORD is set:' \${DB_PASSWORD:+YES}
            echo 'JWT_SECRET is set:' \${JWT_SECRET:+YES}
            
            echo 'Starting containers...'
            docker-compose -f docker-compose.prod.yml --env-file .env.production down --remove-orphans || true
            docker-compose -f docker-compose.prod.yml --env-file .env.production up -d
            
            echo 'Waiting for containers to initialize...'
            sleep 30
            
            echo '‚úÖ Containers started'
          "

      - name: üîç Verify Deployment
        run: |
          echo "üîç Verifying deployment..."
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            cd $DEPLOY_DIR
            
            echo 'Container status:'
            docker-compose -f docker-compose.prod.yml --env-file .env.production ps
            
            echo 'Container health:'
            docker-compose -f docker-compose.prod.yml --env-file .env.production logs --tail=10 backend
            docker-compose -f docker-compose.prod.yml --env-file .env.production logs --tail=10 frontend
            docker-compose -f docker-compose.prod.yml --env-file .env.production logs --tail=10 helpdesk-postgres-prod
          "

      - name: üåê Test Endpoints
        run: |
          echo "üåê Testing application endpoints..."
          ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} "
            cd $DEPLOY_DIR
            echo 'Testing internal endpoints...'
            
            # Wait a bit more for full startup
            sleep 15
            
            # Test backend health
            if curl -f http://localhost:3001/health -s; then
              echo '‚úÖ Backend API responding'
            else
              echo '‚ö†Ô∏è Backend API not responding yet'
            fi
            
            # Test frontend
            if curl -f http://localhost:80 -s -o /dev/null; then
              echo '‚úÖ Frontend responding'
            else
              echo '‚ö†Ô∏è Frontend not responding yet'
            fi
            
            # Test database
            if docker-compose -f docker-compose.prod.yml --env-file .env.production exec -T helpdesk-postgres-prod pg_isready -U helpdesk_user; then
              echo '‚úÖ Database ready'
            else
              echo '‚ö†Ô∏è Database not ready yet'
            fi
          "

      - name: üìã Deployment Summary
        run: |
          echo ""
          echo "üéâ DEPLOYMENT COMPLETED SUCCESSFULLY!"
          echo "====================================="
          echo ""
          echo "üîó **Application URLs:**"
          echo "‚Ä¢ Frontend: http://${{ secrets.VM_HOST }}"
          echo "‚Ä¢ Backend API: http://${{ secrets.VM_HOST }}:3001"
          echo "‚Ä¢ Health Check: http://${{ secrets.VM_HOST }}:3001/health"
          echo "‚Ä¢ WebSocket: ws://${{ secrets.VM_HOST }}:3001"
          echo ""
          echo "üë§ **Default Admin Account:**"
          echo "‚Ä¢ Email: admin@example.com"
          echo "‚Ä¢ Password: admin123"
          echo ""
          echo "üë§ **Default User Account:**"
          echo "‚Ä¢ Email: user@example.com"
          echo "‚Ä¢ Password: user123"
          echo ""
          echo "‚ö†Ô∏è **IMPORTANT: Configure GCP Firewall Rules**"
          echo "Before accessing the application, configure firewall rules for:"
          echo "‚Ä¢ Port 80 (Frontend)"
          echo "‚Ä¢ Port 3001 (Backend API)"
          echo ""
          echo "üìã **Next Steps:**"
          echo "1. Configure GCP firewall rules"
          echo "2. Access application at http://${{ secrets.VM_HOST }}"
          echo "3. Test user authentication and ticket creation"
          echo "4. Verify real-time WebSocket updates"
          echo ""
          echo "üîß **Troubleshooting Commands:**"
          echo "‚Ä¢ Check containers: docker-compose -f $DEPLOY_DIR/docker-compose.prod.yml ps"
          echo "‚Ä¢ View logs: docker-compose -f $DEPLOY_DIR/docker-compose.prod.yml logs"
          echo "‚Ä¢ Restart services: docker-compose -f $DEPLOY_DIR/docker-compose.prod.yml restart"
