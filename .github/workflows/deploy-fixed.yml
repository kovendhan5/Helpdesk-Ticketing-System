---
name: Deploy to Production (Fixed)

on:
  workflow_dispatch: # Only manual trigger
    inputs:
      reason:
        description: "Reason for deployment"
        required: false
        default: "Manual deployment"

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to server
        env:
          VM_IP: ${{ secrets.VM_IP }}
        run: |
          echo "üöÄ Deploying to production server..."

          # Test connectivity first
          echo "üîç Testing server connectivity..."
          echo "Server IP: $VM_IP"

          # Test basic connectivity
          timeout 10 bash -c "echo >/dev/tcp/$VM_IP/22" && echo "‚úÖ Port 22 is reachable" || echo "‚ùå Port 22 unreachable"
            # Test SSH connection with verbose output
          echo "üîê Testing SSH connection..."
          ssh -v -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o BatchMode=yes ${{ secrets.VM_USER }}@$VM_IP 'echo "‚úÖ SSH connection successful"' || {
            echo "‚ùå SSH connection failed. Checking common issues..."
            echo "- Verify VM_IP secret is correct: $VM_IP"
            echo "- Verify SSH_PRIVATE_KEY secret contains valid private key"
            echo "- Check if server is running and SSH service is enabled"
            echo "- Verify firewall allows SSH on port 22"
            exit 1
          }

          # Create deployment package
          tar czf deploy.tar.gz docker-compose.yml backend/ frontend/
            # Deploy in a single SSH session
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ secrets.VM_USER }}@$VM_IP '
            set -e
            
            echo "üèóÔ∏è Setting up deployment environment..."
            sudo mkdir -p /opt/helpdesk-ticketing-system
            sudo chown ${{ secrets.VM_USER }}:${{ secrets.VM_USER }} /opt/helpdesk-ticketing-system
            cd /opt/helpdesk-ticketing-system
            
            # Stop existing containers
            if [ -f "docker-compose.yml" ]; then
              echo "üõë Stopping existing containers..."
              sudo docker-compose down 2>/dev/null || echo "No containers to stop"
            fi
            
            # Clean directory
            echo "üßπ Cleaning deployment directory..."
            rm -rf ./* 2>/dev/null || true
            
            # Install Docker if needed
            if ! command -v docker &> /dev/null; then
              echo "üì• Installing Docker..."
              sudo apt-get update -qq
              sudo apt-get install -y docker.io docker-compose
              sudo systemctl enable docker
              sudo systemctl start docker
              echo "‚úÖ Docker installed"
            else
              echo "‚úÖ Docker already available"
            fi
          '
            echo "üì§ Copying files to server..."
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
            deploy.tar.gz ${{ secrets.VM_USER }}@$VM_IP:/opt/helpdesk-ticketing-system/
            echo "üèóÔ∏è Extracting and starting services..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ secrets.VM_USER }}@$VM_IP '
            set -e
            cd /opt/helpdesk-ticketing-system
            
            # Extract files
            tar xzf deploy.tar.gz
            rm deploy.tar.gz
            
            # Verify docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              echo "‚ùå docker-compose.yml not found!"
              exit 1
            fi
            
            echo "üìã Files in deployment directory:"
            ls -la
            
            # Create environment file
            echo "üîß Creating environment variables..."
            echo "NODE_ENV=production" > .env
            echo "PORT=3001" >> .env
            echo "DB_HOST=postgres" >> .env
            echo "DB_PORT=5432" >> .env
            echo "DB_NAME=helpdesk_db" >> .env            echo "DB_USER=postgres" >> .env
            echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
            echo "SESSION_TIMEOUT=3600000" >> .env
            echo "MAX_LOGIN_ATTEMPTS=5" >> .env
            echo "LOCKOUT_TIME=900000" >> .env
            
            echo "‚úÖ Environment variables created:"
            cat .env
            
            # Clean up any existing containers
            echo "üßπ Cleaning up existing containers..."
            sudo docker system prune -f 2>/dev/null || true
            
            # Start services with verbose output
            echo "üöÄ Starting Docker Compose services..."
            sudo docker-compose up -d --build
            
            echo "‚è±Ô∏è Waiting for containers to initialize..."
            sleep 15
            
            echo "üìä Final container status:"
            sudo docker-compose ps
            sudo docker ps -a
          '

      - name: Comprehensive health check
        env:
          VM_IP: ${{ secrets.VM_IP }}
        run: |
          echo "üè• Running comprehensive health check..."

          # Wait for services to fully start
          sleep 45

          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ secrets.VM_USER }}@$VM_IP '
            cd /opt/helpdesk-ticketing-system
            
            echo "=== CONTAINER STATUS ==="
            sudo docker-compose ps
            
            echo ""
            echo "=== ALL DOCKER CONTAINERS ==="
            sudo docker ps -a
            
            echo ""
            echo "=== BACKEND LOGS ==="
            sudo docker logs helpdesk-backend --tail 30 2>&1 || echo "Backend container not found"
            
            echo ""
            echo "=== FRONTEND LOGS ==="
            sudo docker logs helpdesk-frontend --tail 30 2>&1 || echo "Frontend container not found"
            
            echo ""
            echo "=== POSTGRESQL LOGS ==="
            sudo docker logs helpdesk-postgres --tail 30 2>&1 || echo "PostgreSQL container not found"
            
            echo ""
            echo "=== NETWORK CHECK ==="
            sudo apt-get install -y net-tools 2>/dev/null || true
            sudo netstat -tlnp 2>/dev/null | grep -E ":300[01]|:5432" || echo "No services on expected ports"
            
            echo ""
            echo "=== INTERNAL HEALTH CHECKS ==="
            sudo docker exec helpdesk-backend wget -q --spider http://localhost:3001/health && echo "‚úÖ Backend internal health OK" || echo "‚ùå Backend internal health failed"
            sudo docker exec helpdesk-frontend wget -q --spider http://localhost:3000/health && echo "‚úÖ Frontend internal health OK" || echo "‚ùå Frontend internal health failed"
            sudo docker exec helpdesk-postgres pg_isready -U postgres && echo "‚úÖ PostgreSQL ready" || echo "‚ùå PostgreSQL not ready"
          '
            echo ""
          echo "=== EXTERNAL HEALTH CHECKS ==="
          echo "üåê Testing website accessibility at: http://$VM_IP:3000"
          echo "üîó Testing API accessibility at: http://$VM_IP:3001"
          curl -f -m 10 http://$VM_IP:3000/health && echo "‚úÖ Frontend externally accessible" || echo "‚ùå Frontend not accessible"
          curl -f -m 10 http://$VM_IP:3001/health && echo "‚úÖ Backend externally accessible" || echo "‚ùå Backend not accessible"

          echo ""
          echo "üéâ IF SUCCESSFUL, ACCESS YOUR WEBSITE AT:"
          echo "   Frontend: http://$VM_IP:3000"
          echo "   Backend API: http://$VM_IP:3001"
