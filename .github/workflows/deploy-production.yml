name: ðŸš€ Deploy Helpdesk to GCP Production

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch: # Allow manual triggering

env:
  GCP_VM_IP: "34.173.186.108"
  GCP_VM_USER: "kovendhan2535"
  GCP_VM_ZONE: "us-central1-a"
  DOCKER_BACKEND_IMAGE: "kovendhan5/helpdesk-backend"
  DOCKER_FRONTEND_IMAGE: "kovendhan5/helpdesk-frontend"

jobs:
  security-check:
    runs-on: ubuntu-latest
    name: ðŸ›¡ï¸ Security Verification
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Security Configuration
        run: |
          echo "ðŸ” Checking security configurations..."

          # Check rate limiting configuration
          if grep -q "maxRequests.*1000" backend/src/index.js; then
            echo "âœ… Rate limiting properly configured"
          else
            echo "âŒ Rate limiting not properly configured"
            exit 1
          fi

          # Check Docker security
          if grep -q "USER nginx" frontend/Dockerfile; then
            echo "âœ… Frontend runs as non-root user"
          else
            echo "âŒ Frontend container security issue"
            exit 1
          fi

          if grep -q "USER nodejs" backend/Dockerfile; then
            echo "âœ… Backend runs as non-root user"
          else
            echo "âŒ Backend container security issue"
            exit 1
          fi

          echo "ðŸ›¡ï¸ All security checks passed!"

  build-and-push:
    runs-on: ubuntu-latest
    name: ðŸ—ï¸ Build & Push Docker Images
    needs: security-check
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ env.DOCKER_BACKEND_IMAGE }}:latest,${{ env.DOCKER_BACKEND_IMAGE }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ env.DOCKER_FRONTEND_IMAGE }}:latest,${{ env.DOCKER_FRONTEND_IMAGE }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-to-gcp:
    runs-on: ubuntu-latest
    name: ðŸš€ Deploy to GCP VM
    needs: build-and-push
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.GCP_VM_IP }} >> ~/.ssh/known_hosts

      - name: Test SSH Connection
        run: |
          ssh -o ConnectTimeout=30 ${{ env.GCP_VM_USER }}@${{ env.GCP_VM_IP }} "echo 'SSH connection successful'"

      - name: Generate Production Environment
        run: |
          cat > .env.production << EOF
          # Generated on $(date)
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          NODE_ENV=production
          PORT=3001
          RATE_LIMIT_MAX=5
          RATE_LIMIT_WINDOW=900000
          CORS_ORIGIN=http://${{ env.GCP_VM_IP }}:8080
          EOF

      - name: Create Production Docker Compose
        run: |
          cat > docker-compose.production.yml << 'EOF'
          # Helpdesk Ticketing System - Production Docker Compose
          services:
            postgres:
              image: postgres:15-alpine
              environment:
                POSTGRES_DB: helpdesk
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: ${DB_PASSWORD}
              ports:
                - "5432:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              restart: unless-stopped
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5

            redis:
              image: redis:7-alpine
              command: redis-server --requirepass ${REDIS_PASSWORD}
              ports:
                - "6379:6379"
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "redis-cli", "auth", "${REDIS_PASSWORD}", "ping"]
                interval: 10s
                timeout: 5s
                retries: 5

            backend:
              image: ${{ env.DOCKER_BACKEND_IMAGE }}:latest
              environment:
                - NODE_ENV=production
                - DB_HOST=postgres
                - DB_NAME=helpdesk
                - DB_USER=postgres
                - DB_PASSWORD=${DB_PASSWORD}
                - JWT_SECRET=${JWT_SECRET}
                - REDIS_HOST=redis
                - REDIS_PASSWORD=${REDIS_PASSWORD}
                - PORT=3001
              ports:
                - "3001:3001"
              depends_on:
                postgres:
                  condition: service_healthy
                redis:
                  condition: service_healthy
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
                interval: 30s
                timeout: 10s
                retries: 3

            frontend:
              image: ${{ env.DOCKER_FRONTEND_IMAGE }}:latest
              ports:
                - "8080:80"
              depends_on:
                backend:
                  condition: service_healthy
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:80"]
                interval: 30s
                timeout: 10s
                retries: 3

          volumes:
            postgres_data:

          networks:
            default:
              driver: bridge
          EOF

      - name: Upload deployment files to GCP VM
        run: |
          scp docker-compose.production.yml ${{ env.GCP_VM_USER }}@${{ env.GCP_VM_IP }}:~/docker-compose.yml
          scp .env.production ${{ env.GCP_VM_USER }}@${{ env.GCP_VM_IP }}:~/.env

      - name: Install Docker on GCP VM (if needed)
        run: |
          ssh ${{ env.GCP_VM_USER }}@${{ env.GCP_VM_IP }} << 'ENDSSH'
            # Install Docker if not present
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker $USER
            fi
            
            # Install Docker Compose if not present
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            
            echo "âœ… Docker installation complete"
          ENDSSH

      - name: Deploy Application to GCP VM
        run: |
          ssh ${{ env.GCP_VM_USER }}@${{ env.GCP_VM_IP }} << 'ENDSSH'
            echo "ðŸš€ Starting Helpdesk production deployment..."
            
            # Create application directory
            sudo mkdir -p /opt/helpdesk-production
            sudo chown $USER:$USER /opt/helpdesk-production
            cd /opt/helpdesk-production
            
            # Copy files to production directory
            cp ~/docker-compose.yml .
            cp ~/.env .
            
            # Stop any existing containers
            sudo docker-compose down || true
            
            # Pull latest images
            echo "ðŸ“¥ Pulling latest Docker images..."
            sudo docker-compose pull
            
            # Start services
            echo "ðŸš€ Starting services..."
            sudo docker-compose up -d
            
            # Wait for services to be ready
            echo "â³ Waiting for services to start..."
            sleep 60
            
            echo "âœ… Deployment complete!"
          ENDSSH

      - name: Verify Deployment
        run: |
          echo "ðŸ§ª Testing deployed application..."

          # Wait a bit more for services to fully start
          sleep 30

          # Test backend health
          if curl -f -s --max-time 30 http://${{ env.GCP_VM_IP }}:3001/health; then
            echo "âœ… Backend health check: PASSED"
          else
            echo "âŒ Backend health check: FAILED"
            ssh ${{ env.GCP_VM_USER }}@${{ env.GCP_VM_IP }} "cd /opt/helpdesk-production && sudo docker-compose logs backend"
            exit 1
          fi

          # Test frontend
          if curl -f -s -I --max-time 30 http://${{ env.GCP_VM_IP }}:8080; then
            echo "âœ… Frontend health check: PASSED"
          else
            echo "âŒ Frontend health check: FAILED"
            ssh ${{ env.GCP_VM_USER }}@${{ env.GCP_VM_IP }} "cd /opt/helpdesk-production && sudo docker-compose logs frontend"
            exit 1
          fi

      - name: Get Service Status
        run: |
          ssh ${{ env.GCP_VM_USER }}@${{ env.GCP_VM_IP }} << 'ENDSSH'
            echo "ðŸ“Š Service Status:"
            cd /opt/helpdesk-production
            sudo docker-compose ps
            
            echo ""
            echo "ðŸ” Container Health:"
            sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          ENDSSH

  notify-success:
    runs-on: ubuntu-latest
    name: ðŸŽ‰ Deployment Success Notification
    needs: deploy-to-gcp
    if: success()
    steps:
      - name: Success Notification
        run: |
          echo "======================================================================"
          echo "ðŸŽ‰ HELPDESK PRODUCTION DEPLOYMENT SUCCESSFUL!"
          echo "======================================================================"
          echo ""
          echo "ðŸŒ Your application is now LIVE at:"
          echo "   Frontend: http://${{ env.GCP_VM_IP }}:8080"
          echo "   Backend API: http://${{ env.GCP_VM_IP }}:3001"
          echo "   Health Check: http://${{ env.GCP_VM_IP }}:3001/health"
          echo ""
          echo "ðŸ”’ Security Features Active:"
          echo "   âœ… Login rate limiting (5 attempts/15min)"
          echo "   âœ… Redis token storage"
          echo "   âœ… JWT authentication"
          echo "   âœ… Content Security Policy"
          echo "   âœ… Non-root containers"
          echo "   âœ… Input sanitization"
          echo ""
          echo "ðŸ—ï¸ Deployed Images:"
          echo "   Backend: ${{ env.DOCKER_BACKEND_IMAGE }}:${{ github.sha }}"
          echo "   Frontend: ${{ env.DOCKER_FRONTEND_IMAGE }}:${{ github.sha }}"
          echo ""
          echo "âœ… Production deployment completed successfully!"
          echo "======================================================================"

  notify-failure:
    runs-on: ubuntu-latest
    name: âŒ Deployment Failure Notification
    needs: deploy-to-gcp
    if: failure()
    steps:
      - name: Failure Notification
        run: |
          echo "âŒ Deployment failed. Check the logs above for details."
          echo "ðŸ”§ Troubleshooting steps:"
          echo "1. Check SSH connectivity to GCP VM"
          echo "2. Verify Docker images were built successfully"
          echo "3. Check GCP VM resources and network settings"
          echo "4. Review container logs for specific errors"
